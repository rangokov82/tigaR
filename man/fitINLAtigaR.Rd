% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tigaR.R
\name{fitINLAtigaR}
\alias{fitINLAtigaR}
\title{Fit tigaR to multiple data rows}
\usage{
fitINLAtigaR(
  forms,
  dat,
  dat1 = NULL,
  timefac,
  groupfac,
  ZSpline,
  fams = "zinb",
  shrinksimul,
  logdisp = c(0, 0.01),
  precerr = c(1, 10^(-5)),
  curvedispfun = NULL,
  logitp0 = c(0, 0.01),
  ncpus = 2,
  effoutput = TRUE,
  keepmargrand = FALSE,
  keepmarghyper = TRUE,
  setthreads1 = TRUE,
  showupdate = FALSE,
  silentINLA = 2L,
  updateby = 5000,
  ndigits = 5,
  addpackage = NULL,
  safemode = TRUE,
  cf = NULL,
  orthogonal = FALSE,
  shrink = FALSE,
  multivar = FALSE,
  rho = 0,
  ...
)
}
\arguments{
\item{forms}{Formula, or list of formulas the length of which equals the number of data rows. See inla and f for specification of the model formula.}

\item{dat}{Matrix or data frame containing the data. Rows are features, columns are samples.}

\item{dat1}{Matrix of data frame containing explanatory data set. Rows are features, columns are samples.}

\item{timefac}{Vector representing the time points of the design matrix}

\item{groupfac}{Factor representing the groups of the design matrix}

\item{fams}{Character string. Either equal to "poisson", "zip" (zero-inflated Poisson), "nb" (negative binomial), or "zinb" (zero-inflated negative binomial), "gaussian": likelihood to be used.}

\item{shrinksimul}{A list object resulting from tigaRshrinkSeq or tigaRshrinkGauss}

\item{logdisp}{Numeric vector of length 2. Mean and precision of the Gaussian prior of log-size. Only relevant when fams = "nb" or fams = "zinb".}

\item{precerr}{Numeric vector of length 2. Shape and rate of the Gamma-prior for precision of Gaussian random variables.}

\item{curvedispfun}{A smoothing function that results from ShrinkSeq when run with curvedisp=TRUE. It can be accessed by object$curvedispfun where object is the result from ShrinkSeq. Only relevant when fams = "nb".}

\item{logitp0}{Numeric vector of length 2. Mean and precision of the Gaussian prior of logit-p0 (zero-mass). Only relevant when fams = "zip" or fams = "zinb".}

\item{ncpus}{Integer. The number of cpus to use for parallel computations.}

\item{effoutput}{Boolean. If FALSE, all INLA output will be saved. If TRUE, some fields will be deleted.}

\item{keepmargrand}{Boolean. Do you wish to save the marginals of the random effect regression parameters (beta's)?}

\item{keepmarghyper}{Boolean. Do you wish to save the marginals of the hyper-parameters?}

\item{setthreads1}{Boolean. If TRUE, sequential computation is forced within each call to INLA.}

\item{showupdate}{Boolean. Do you wish to see updates on progression of the computation? TRUE may slow down the computations due to less efficient parallel computation.}

\item{silentINLA}{How to silence the output of INLA? NOTE: currently not all INLA output can be silenced.}

\item{updateby}{Integer, only relevant when showupdate=TRUE. Show an update for each updateby number of features executed.}

\item{ndigits}{Integer. Numerical precision in digits for the output.}

\item{addpackage}{Character string. Additional package that you wish to export to slave nodes when parallel computing.}

\item{safemode}{Boolean. Only relevant for fams="zinb" or fams="nb". If fitting fails, should it re-run in a safe mode?}

\item{cf}{List. control.fixed argument for inla.}

\item{orthogonal}{Boolean. If TRUE, ortogonalized predictor data set (DNA copy number) to the respons data set (mRNA or miRNA gene expression)}

\item{shrink}{Boolean. If TRUE, perform the shrinkage of DNA copy number neighborhoods triplets.}

\item{multivar}{Boolean. If TRUE, perform multivariate estimation of the parameters.}

\item{rho}{Number representing the level of the correlation between the triplets.}

\item{...}{Further arguments passed on to inla.}

\item{Zspline}{Design matrix for thin-plate splines}
}
\value{
This function return number of degree of freedom used in the model testing.
}
\description{
This is a wrapper function that facilitates multiple calls to INLA using parallel processing. It currently supports the following univariate likelihoods: Poisson, negative binomial, zero-inflated negative binomial, Gaussian.
}
